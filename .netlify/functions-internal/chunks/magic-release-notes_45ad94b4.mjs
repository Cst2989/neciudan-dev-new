const id = "magic-release-notes.md";
						const collection = "post";
						const slug = "magic-release-notes";
						const body = "\nWe used to have a small annoying problem in my company. I call it small-annoying because it was small enough not to deserve allocated resources to solve, but it was annoying enough to bother me every couple of weeks. \n\nWe have a Frontend React Application that communicates to a backend API, a gateway to multiple services, and one main monolithic application. \n\nIt's a standard architecture, so let me know if this has ever happened to you. \n\nYou need to do a production release; you last did one about ten days ago, and now that the stars have aligned, you have the perfect window to press the button. \n\nThe problem? You have no idea what exactly you are releasing.\n\nAnd here you can see how annoying this was for me. As I usually was in charge of pushing the deploy button, I had to ensure everything in line to be released was tested, verified, and given the green light to be deployed. \n\nHere is what the process looks like:\n\nFirst, I check the status of JIRA tickets for `Ready for Release` and write down the ticket number and title. Then, I go commit by commit in the Frontend React Application, note the JIRA tickets in the title, write them down, and do the same for our Backend Go Application and other services. \n\nFinally, I had a list that looked like this: \n\n<img src=\"/images/articles/first-notes.png\" alt=\"First Notes for Release\" /> \n\nGathering all this information took me around 30 minutes; like I said, it was a small problem. \n\nThen, I posted on different development Slack channels, letting the team know what was being released and asking anybody with any objections to speak now or face the consequences.\n\nFinally, I would push the button, release the main branch to Production, and let everybody know in the #general Slack channel. We would do some manual tests, everybody would be happy, and a few days later, we would repeat the experience. \n\nSometimes, the annoyance grows and becomes a real problem. I might forget to announce releases, and stakeholders will be confused about what is in Production. Some bugs might sneak their way because I missed them in the commit list, or worse, dependency deployments might cause the app to crash. \n\nAfter several times when it became a problem and people complained about it,  I finally got around to automating this process. \n\nHere is what I need from this feature: \n- Semver versioning \n- Github Action that adds the title of PR and content to the changelog  when the PR is merged\n- A button that creates a new release tag gets everything in the changelog and sets it as the description for the release \n- Sends Slack notifications to a specific channel with release notes\n\nLet's get pull up our sleeves and get to work.\n\n## Semantic versioning (aka SemVer)\n\nNot all PRs are the same; some have complex features that took weeks to build, while others have small fixes of current implementations, different chores, or security patches. \n\nThis is what semantic versioning represents. It is a series of numbers that lets everybody looking at your project know what the next version has inside of it. \n\nYou see it all the time in npm packages. It's three numbers that are separated by single dots Ex: 1.0.0 : \n\n<img src=\"/images/articles/semver.jpg\" alt=\"Semver Explained\" /> \n\nThe first number represents a major change containing breaking changes. That means if you use this project and upgrade to this version, you would have to change how you use it for it to work. It's typical for a rebrand of your project, or you add multiple sets of features or change the API of how your features work. \n\nThe second number represents minor versions that add non-breaking changes, such as new features, components, style changes, etc. If I use your project and upgrade to this version, it will work without changing anything in my code. \n\nLastly, the patch version is the last number, representing quick fixes, security patches, or small improvement requests. \n\nThere you have it, SemVer explained. We want this for our release notes; let's see how we can implement it. \n\n## Magic Github Action\n\nHave you ever had those repetitive tasks you do whenever you merge code? GitHub Actions solves those problems. Instead of manually creating tags, updating changelogs, and writing release notes, you set up a workflow file and let GitHub handle it.\n\nIt's like having a tiny dev that sits there watching your repository 24/7, ready to jump in whenever you merge code. Here's how I configured ours:\n\nWe already had the practice of naming our PRs depending on the type of change we are introducing, for example:\nfeat(COM-1000): this is a new feature \nfix(COM-666): fixed an annoying bug \nchore(COM-123): updates the README file \nmajor(COM-1444): this is a major breaking change that requires both frontend and backend to be carefully deployed, or else we have a problem\n\nThe next step was to use this title somewhere, and I knew just the place. GitHub already integrates releases based on tags; the problem is that you have to write the release description yourself. \n\nI decided to write a GitHub Actions script that does the following when you merge a PR: \n- Creates a \"Draft Release\" or takes the one that already exists \n- The next version is calculated based on the PR title and the previous tag version, and a tag is created.\n- It does this at every PR merge as long you have yet to release it and keeps adding the titles to the Draft Release. \nHere is what the flow would look like. \n\nWe just released version 2.10 in Production yesterday, and today, we're merging three tickets:\n\nFirst is fix(COM-666): fixed an annoying bug. The GitHub Action checks the current latest tag (2.10.0) and, since this is a fix, bumps the patch version to 2.10.1. It creates a draft release and adds the PR title under the \"Patches\" section.\n\nNext, we merge feat(COM-789): add new login page. The Action sees this is a feature, so it bumps the minor version to 2.11.0 and adds the PR title under \"Minor Changes\" in the same draft release.\n\nFinally, we merge chore(COM-999): update dependencies. Another patch, so it becomes 2.11.1.\n\nLet's break down how this works in the code. To use this in your project, create a .github folder inside the root of your project (if you don't have one already); inside it, create a workflow director and add a file named `semantic-versioning.yml` :\n\n```\nname: Semantic Versioning and Draft Release\n\non:\n  pull_request:\n    types: [closed]\n    branches:\n      - main\n```\n\nThis code tells our tiny dev, \"Hey, only wake up when someone merges a PR to main.\" Because that's when we want to update our release notes.\n\n```\njobs:\n  process-pr:\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n```\n\nThe if condition is crucial here - we don't want to create release notes for PRs that were closed without merging. That would be messy. And we need contents: write permission because, well, we're going to be creating tags and messing with releases.\n\n```\nsteps:\n  - name: Checkout code\n    uses: actions/checkout@v3\n    with:\n      fetch-depth: 0\n      token: ${{ secrets.GITHUB_TOKEN }}\n```\nSteps in GitHub Actions are sequential tasks that run one after another. Think of them as recipesâ€”each step needs to be completed successfully before proceeding to the next one. The `uses: actions/checkout@v3` tells GitHub to use version 3 of the official checkout action, a pre-built action that handles git clone operations.\n\nThe checkout step clones our repository into the GitHub Actions runner. The workflow needs access to our code to process tags and create releases, which is where the GITHUB_TOKEN comes in - it's an automatically generated token that GitHub creates for each workflow run with the permissions we specified earlier.\n\nGitHub Actions fetches the latest commit by default to save time and bandwidth. But for versioning, we need the complete git history, including all tags. That's what fetch-depth: 0 does - it tells git to fetch everything.\n\nThen we get in the meat of our business: first, it fetches the latest version tag:\n\n```\n- name: Get latest tag\n  run: |\n    git fetch --tags\n    LATEST_TAG=$(git tag -l | sort -V | tail -n 1)\n```\n\nThen comes the interesting part - determining the version bump based on the PR title:\n\n```\nif [[ $PR_TITLE == *\"BREAKING CHANGE\"* ]] || [[ $PR_TITLE == *\"major\"* ]]; then\n  BUMP_TYPE=\"major\"\nelif [[ $PR_TITLE == *\"feat:\"* ]] || [[ $PR_TITLE == *\"minor\"* ]]; then\n  BUMP_TYPE=\"minor\"\nelif [[ $PR_TITLE == *\"fix:\"* ]] || [[ $PR_TITLE == *\"patch\"* ]]; then\n  BUMP_TYPE=\"patch\"\nfi\n```\n\nIt looks for keywords in the PR title - \"BREAKING CHANGE\" or \"major\" bumps the major version, \"feat:\" bumps minor, and \"fix:\" bumps patch. The version is calculated by splitting the current version and incrementing the correct number:\n\n```\ncase $BUMP_TYPE in\n  major)\n    NEW_VERSION=\"$((MAJOR + 1)).0.0\"\n    ;;\n  minor)\n    NEW_VERSION=\"${MAJOR}.$((MINOR + 1)).0\"\n    ;;\n  patch)\n    NEW_VERSION=\"${MAJOR}.${MINOR}.$((PATCH + 1))\"\n    ;;\nesac\n```\n\nFinally, it updates the draft release by adding the PR title under the right section (Breaking Changes, Minor Changes, or Patches). If no draft exists, it creates one:\n\n```\nif gh release view \"Latest Release\" --json body &>/dev/null; then\n  CURRENT_BODY=$(gh release view \"Latest Release\" --json body -q '.body')\n  NEW_BODY=$(update_release_body \"$CURRENT_BODY\" \"$SECTION\" \"${{ env.PR_ENTRY }}\")\n  echo \"$NEW_BODY\" | gh release edit \"Latest Release\" --draft --notes-file -\nelse\n  NEW_BODY=$(update_release_body \"\" \"$SECTION\" \"${{ env.PR_ENTRY }}\")\n  echo \"$NEW_BODY\" | gh release create \"Latest Release\" --draft --title \"Latest Release\" --notes-file -\nfi\n```\n\nNow, whenever someone merges a PR, the release notes are written by themselves. The draft release keeps collecting changes until we're ready to publish it to Production. Here is what it looks like: \n\n<img src=\"/images/articles/latest-release-draft.png\" alt=\"Github Latest Release Draft\" /> \n\n## Pressing the button \n\nNow that we have a Draft Release, we are always aware of what is in the main, and we can deploy it anytime. \n\nOf course, you can do it manually by publishing the draft release, but I wanted to add some extra things when a release is published. \n\nRemember semantic versioning? I want the GitHub Action to get the latest tag and name the release with that tag. Then, I want to change the version in our package.json file to that specific version. Finally, I want our GitHub Action to create a release branch from our main branch, which we can use to deploy to Production automatically. \n\nLet's implement this new flow.\n\nFirst, we create another workflow called `publish-release.yml` in our workflows folder. This one is a little different, as we don't want it to run automatically; we have to specify its manual: \n\n```\nname: Create Release Branch and Release\n\non:\n  workflow_dispatch:\n```\n\nThis code will create a nice green button in the GitHub Actions tab that, when pressed, will run our GitHub Action like so: \n\n<img src=\"/images/articles/run-workflow.png\" alt=\"Run Workflow image in Github\" /> \n\nWe break our workflow into three main steps: \n- prepare step\n- create-release-branch\n- publish-release\n\nOur `prepare` step is pretty standard. It gets the code from our code repository, declares our output, and sets the GitHub token to allow our workflow to push changes to it. Finally, it gets the latest tag of our repo and stores it as a variable for later usage.\n\n```\njobs:\n  prepare:\n    runs-on: ubuntu-latest\n    outputs:\n      latest_tag: ${{ steps.get_tag.outputs.tag }}\n    steps:\n - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GITHUB_TOKEN }}\n- name: Get latest tag\n        id: get_tag\n        run: |\n          LATEST_TAG=$(git tag -l | sort -V | tail -n 1)\n          echo \"tag=$LATEST_TAG\" >> $GITHUB_OUTPUT\n```\nNext, our `create-release-branch` job needs write permissions to the repository. It deletes the current release branch because we no longer need it and creates a new release branch from the main branch.\n\nWith the release branch created, it writes the latest tag into the package.json and finally pushes the changes to the repository. \n\n```\n  create-release-branch:\n    needs: prepare\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n - uses: actions/checkout@v4\n        with:\n          ref: main\n          token: ${{ secrets.GITHUB_TOKEN }}\n      \n - name: Update package version and create branch\n        run: |\n          # Get the latest tag\n          LATEST_TAG=${{ needs.prepare.outputs.latest_tag }}\n          \n          # Delete release branch locally and remotely if it exists\n          git push origin --delete release || true\n          git branch -D release || true\n          \n          # Create new release branch from main\n          git checkout -b release\n          \n          # Update version in package.json directly\n          jq \".version = \\\"${LATEST_TAG}\\\"\" package.json > temp.json && mv temp.json package.json\n          \n          echo \"Updated package.json to version ${LATEST_TAG}\"\n          cat package.json | grep version\n          \n          # Configure git\n          git config user.name \"github-actions[bot]\"\n          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n          \n          # Commit and push changes\n          git add package.json\n          git commit -m \"chore: update version to ${LATEST_TAG}\"\n          git push -f origin release\n\n```\n\nWhat we have now is a branch named `release` with the latest commit and the version name. We can then use this in our CI/CD Netlify or Vercel or whatever Cloud provider you want to automatically release this branch to Production every time some new code is pushed to it. \n\n<img src=\"/images/articles/published-to-netlify.png\" alt=\"Publish to Netlify example\" /> \n\nAnd now, finally, if the previous two jobs were successful, we can publish our release with the adequately named job ` publish-release`: \n\n```\n  publish-release:\n    needs: [prepare, create-release-branch]\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GITHUB_TOKEN }}\n\n - name: Publish draft release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          # Use the tag from prepare job\n          LATEST_TAG=${{ needs.prepare.outputs.latest_tag }}\n          \n          # Update the draft release title and publish it\n          gh release edit \"Latest Release\" --title \"$LATEST_TAG\" --tag \"$LATEST_TAG\" --draft=false\n\n```\n\nThere you have it: click a button, and magic happens. This will publish the release to the latest version so you can see it in the releases tab on GitHub and start again with more PR merges. \n\n## Getting Notified\n\nThe final piece of the puzzle was getting these release notes to where people actually hang out - Slack. You know how it goes, you can have the most beautiful documentation in the world, but if people need to actively go looking for it, they probably won't.\n\nLet me tell you about the easiest integration I've ever done.\n\nFirst, head over to https://slack.github.com/ and install the GitHub-Slack app. It's the official app, so you know it's safe and well-maintained.\n\nNext, you'll want to create some dedicated channels for these notifications. In our case, we created two: #frontend-releases and #backend-releases. \n\nFinally, here's the magic part. Go to your new channel and type this command:\n\n```\n/github subscribe owner/repo releases\n```\n\nJust replace \"owner\" and \"repo\" with your actual GitHub details. For example, if your repo lives at https://github.com/cst2989/release-notes, you'd type:\n\n```\n/github subscribe cst2989/release-notes releases\n```\n\nThat's it! Every time you publish a release, Slack will automatically post the release notes in your channel. There are no webhooks to configure or custom integrations to maintain, just instant notifications where your team already lives.\n\nAnd remember those beautifully formatted release notes we set up earlier? They'll show up in Slack looking just as clean and organized. Your team will always know exactly what's going into Production, and more importantly, they'll actually see it.\n\n<img src=\"/images/articles/final-release-message.png\" alt=\"Slack message with release notes\" /> \n\n## Conclusion and Alternatives\n\nIf you want to keep track of all the PRs you are merging in a clean way, you can use the GitHub Actions above to automate your release notes. \n\nDoing this will save you time, reduce human error, and keep your team informed about what's going into Production.\n\nI would also reccomend an open source Github Action you can find on the marketplace called `release-drafter` https://github.com/release-drafter/release-drafter that does the same thing but with a little more configuration and it allows to create templates.  \n";
						const data = {publishDate:new Date(1737158400000),title:"Magic Release Notes",excerpt:"Just merge your PRs without worrying about release notes. Let GitHub Actions do the work for you by creating a Draft Release and then push to production by clicking a button and get notified on Slack.",image:"/images/articles/magic-release-bg.png",category:"deployment"};
						const _internal = {
							type: 'content',
							filePath: "/Users/danneciu/Desktop/apps/neciudan-dev-v2/src/content/post/magic-release-notes.md",
							rawData: "\ntitle: 'Magic Release Notes'\nexcerpt: 'Just merge your PRs without worrying about release notes. Let GitHub Actions do the work for you by creating a Draft Release and then push to production by clicking a button and get notified on Slack.'\npublishDate: 2025-01-18\nimage: '/images/articles/magic-release-bg.png'\ncategory: 'deployment'\nreadTime: '5 min read'",
						};

export { _internal, body, collection, data, id, slug };
