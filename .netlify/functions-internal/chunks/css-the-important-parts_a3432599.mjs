import { f as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_b7d88353.mjs';
import 'clsx';

const html = "<p>CSS (Cascading Style Sheets) is a language used for describing the presentational layout of a document. More specifically it is used together with HTML to create beautiful and user-friendly websites or apps.</p>\n<p>But since the first version of CSS came out in 1996, the language has evolved into a tool used to create really awesome things. Like the <a href=\"http://pattle.github.io/simpsons-in-css/\">entire cast of The Simpsons using just CSS</a> or a <a href=\"https://codepen.io/42EG4M1/pen/wBYmMK\">CSS-only Game Boy</a> or a <a href=\"https://codepen.io/seanseansean/pen/JdMMdG\">pretty cool starry night</a> and so much more.</p>\n<p>Pretty amazing, right?</p>\n<p>In this article, we will highlight how CSS works under the hood, what are the rules CSS uses to evaluate blocks of code, and some tips and tricks that can help you reach the next level in your journey to CSS Mastery.</p>\n<h2 id=\"how-does-css-actually-work\">How Does CSS actually work?</h2>\n<p>When you start writing HTML, without adding CSS, the browser will render your elements in normal layout flow. Even after adding some CSS to your elements, if you do not change the display or position property, they will still be rendered in the normal flow.</p>\n<p>What does that even mean?</p>\n<p><strong>The layout model</strong> dictates how your element behaves by default, and what CSS properties your element has access to.</p>\n<p>Here are the available layout models:</p>\n<ul>\n<li>Normal Flow</li>\n<li>Positioned Layout (absolute, block)</li>\n<li>Flex</li>\n<li>Grid</li>\n<li>Table</li>\n</ul>\n<p>Have you not noticed that z-index does not work if you do not apply the position property to your element? Well, this is the reason. The property is not available in the normal flow, or in some of the other layouts as well.</p>\n<p>Adding position:absolute will switch your element from the normal layout module to the positioned one. In this layout model you have access to extra properties, like z-index.</p>\n<p>z-index for example, determines the layout order of elements. If you have two elements in the same position and you want to stack them, the one with the higher z-index value will be on the top.</p>\n<p>If you want to send an element to the bottom of the stack, just set it’s z-index value to a negative number.</p>\n<p>A very important detail to remember is that z-index is only useful in the same stacking context.</p>\n<p>A stacking context is the collection of child elements inside a parent element. So for example, if we have <code>.parent1 { z-index: 1; }</code> and inside we have <code>.child1 { z-index: 999; }</code> the child element will not be stacked against other elements outside of the parent.</p>\n<p><a href=\"https://codepen.io/cst2989/pen/ZExJBKw?editors=1100\">Here is a concrete example</a> to see this in action:</p>\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/stacking.webp\" alt=\"Stacking context example\"> \n</p>\n<p>As you can see above, it does not matter that child1 has <code>z-index:999</code> and child2 has <code>z-index:-1</code> because we compare their stacking context.</p>\n<p>So each layout model has its own properties and rules. And it shares some common ones as well. For example, both flex and grid contain the gap property to set the spacing between the items.</p>\n<p>From this, it’s only a matter of figuring out what properties are implemented in which layout model, and then you will have fewer problems with CSS behaving differently from one context to another.</p>\n<h2 id=\"specificity-rules-are-made-to-be-followed\">Specificity. Rules are made to be followed</h2>\n<p>It took me a while to understand how specificity worked in CSS. It seemed unimportant (ironically) because everything just worked.</p>\n<p>So what if sometimes I had to add a few <code>!important</code> here and there. Or move some code blocks lower in the CSS file to make sure they are applied last. Or worst-case scenario, duplicate some code for different classes. In the end, it worked and that was what mattered at the time.</p>\n<p>I realized how wasteful I was when I had to write optimized code for web applications visited by millions of users. And how hard to debug my code actually was, and little by little I started to understand the rules the Browser Gods act upon us mortals.</p>\n<p>So what is specificity and how does CSS work? Here is the definition from <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity\">Mozilla Developer Network</a>:</p>\n<blockquote>\n<p>Specificity is the means by which a browser decides which CSS property values are the most relevant to an element and therefore will be applied. Specificity is only based on the matching rules which are composed of CSS selectors of different sorts.</p>\n</blockquote>\n<p>Basically, the Browser looks at your CSS rule and gives it a score. Actually 4 scores.</p>\n<p>Four numbers separated by a comma <code>0, 0, 0, 0</code></p>\n<p>Then when you have two colliding CSS rules it goes through the first digit and compares them if there is no clear winner it goes to the second digit and so on.</p>\n<p>If all columns are equal, the browser will pick the rule based on the order. Here is where the Cascade name comes into place. It takes the one closer to the bottom.</p>\n<p>Here is the breakdown of the four digits:</p>\n<p>The first digit represents if the element has inline styles.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>&#x3C;p style=\"color:red\">Hello World&#x3C;/p></span></span></code></pre>\n<p>The second digit represents the number of #ids in your CSS rule.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>&#x3C;p id=\"myParagraph\">Hello World&#x3C;/p></span></span></code></pre>\n<p>or</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>#myParagraph {</span></span>\n<span class=\"line\"><span>  color: blue;</span></span>\n<span class=\"line\"><span>}</span></span></code></pre>\n<p>The third digit is the number of classes, pseudo-classes, and attributes your CSS rule has.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>&#x3C;style></span></span>\n<span class=\"line\"><span>.myParagraphClass {</span></span>\n<span class=\"line\"><span>  color: green;</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span>&#x3C;/style></span></span></code></pre>\n<p>And lastly, we have the number of elements and pseudo-elements.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>&#x3C;p>Hello World&#x3C;/p></span></span>\n<span class=\"line\"><span>&#x3C;style></span></span>\n<span class=\"line\"><span>p {</span></span>\n<span class=\"line\"><span>  color: yellow;</span></span>\n<span class=\"line\"><span>}</span></span>\n<span class=\"line\"><span>&#x3C;/style></span></span></code></pre>\n<p>So for each rule in each column, we increase the score of that column.</p>\n<p>Now you may have read that inline-styles give you a score of 1000, ids of 100, and so forth. This is not true.</p>\n<p>For example. Let’s say we have an element with 102 classes and just one ID. Like the following code:</p>\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/code.png\" alt=\"Stacking context example\"> \n</p>\n<p>If you would follow the rule recommended by some articles and w3school, the ID should have a score of 100, and the class should have a score of 103 resulting in a blue <code>Hello World</code> text. But if you check this in your browser it’s actually red.</p>\n<p>Browsers do not compare apples with oranges. The browser first checks if we have conflicting rules at the inline-style level and applies the score there, then goes to IDs and so on and so forth.</p>\n<p>Another example would be:</p>\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/code2.png\" alt=\"Stacking context example\"> \n</p>\n<p>The <code>#test { color: red; }</code> has a specificity score of <code>0,1,0,0</code>. While the second CSS rule <code>.test-1-parent #test { color: yellow; }</code> has a specificity score of <code>0,1,1,0</code>. The first column is equal, so the Browser moves to the second column where both have a value of 1.</p>\n<p>Then we move to the third column where color:yellow is the winner.</p>\n<h2 id=\"collapsing-margins\">Collapsing Margins</h2>\n<blockquote>\n<p>“In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.“ — W3C</p>\n</blockquote>\n<p>I am ashamed to admit this, but in my second to the third year as a professional developer, I did not know about collapsing margins. Even worse than that, in my ignorance, I would argue with designers that complained that the spacing between elements was off.</p>\n<p>I would open the DevTools and show them, margin-top:50px see? And they would nod, in that I-see-it-but-I-don’t-believe-it way.</p>\n<p>For this, I want to formally apologize to all designers that I did this to or to all designers that suffer from this because of ignorant developers like me.</p>\n<p>Hopefully, I can make amends with this article and educate other poor ignorant frontend developers and you will never have to go through this again.</p>\n<p>As you can imagine, collapsing margins, are the reason even though we had margin-top:50px; on the element the margin could be different. And here is why.</p>\n<p>When two vertical margins (top and bottom) interact with one another, CSS has a weird rule, it makes them duke it out and the bigger one wins.</p>\n<p>For example two HTML elements on the same level in the DOM, <code>.div1 { margin-bottom: 30px; }</code> and <code>.div2 { margin-top: 20px; }</code> , you would expect the distance to be the sum of the margins. But in fact, the collapsing margin rule comes into effect, and we only have 30px (the bigger margin from .div1) between them.</p>\n<p>On the other hand, if one of the elements has a negative margin, <code>.div2 { margin-top: -20px; }</code> then it behaves as you expect. And the margin between them is the sum of 10px.</p>\n<p>More mind-blowing though is when both elements have negative margins. For example, <code>.div1 { margin-bottom: -50px; }</code> and <code>.div2 { margin-top: -20px; }</code> you would expect again, either the sum or the biggest in mathematical terms to be the result, as we know -20 is bigger than -50 because it’s closer to zero, but NO who invented CSS said no to proper maths and the margin between them is -50px. Amazing!</p>\n<p><a href=\"https://codepen.io/cst2989/pen/eYMRQwE\">Here is a Codepen</a> to simulate all examples:</p>\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/collapsing.webp\" alt=\"Collapsing margin example\"> \n</p>\n<p>One more thing to take into consideration is the parent-child relationship between elements where again collapsing margins can cause trouble.</p>\n<p>If the parent element has a margin, let’s say .parent { margin-top: 50px; } and the first child of this element also has a margin .child-1 { margin-top: 20px; } the margins will collapse again and we will only see the bigger one.</p>\n<p><a href=\"https://codepen.io/cst2989/pen/oNqwJgQ\">Here is an example</a>:</p>\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/child-margin.webp\" alt=\"Child margin example\"> \n</p>\nSo that’s how collapsin\ng margins work. Now you may be wondering how to stop it. Easily enough, if you apply anything between the margins, like a border-top or a padding-top then the margins will not touch each other and will not collapse at all.\n<p>Think about this physical barrier as the referee that keeps two boxers at bay from fighting each other when the round ends.</p>\n<h2 id=\"in-conclusion\">In Conclusion</h2>\n<p>CSS is hard! It has all sorts of wacky behavior. But if you know on which layout model you are, you have a better chance of figuring it out.</p>\n<p>Specificity rules are there to decide between conflicting CSS properties. Remember the 4 levels and how to count the score.</p>\n<p>And if margins are giving you a problem, remember that the physical barrier between your elements will keep them from fighting each other</p>\n<p>You know what they say, a <code>border-top: 1px solid transparent</code>, keep the collapsing margins away.</p>";

				const frontmatter = {"title":"CSS: The !Important Parts","excerpt":"Struggling with CSS is a common practice, here we explain how it works and common problems that can appear in your code.","publishDate":"2022-07-22T00:00:00.000Z","image":"/images/articles/css-is-awesome.webp","category":"CSS","readTime":"8 min read","readingTime":9};
				const file = "/Users/danneciu/Desktop/apps/neciudan-dev-v2/src/content/post/css-the-important-parts.md";
				const url = undefined;
				function rawContent() {
					return "\nCSS (Cascading Style Sheets) is a language used for describing the presentational layout of a document. More specifically it is used together with HTML to create beautiful and user-friendly websites or apps.\n\nBut since the first version of CSS came out in 1996, the language has evolved into a tool used to create really awesome things. Like the [entire cast of The Simpsons using just CSS](http://pattle.github.io/simpsons-in-css/) or a [CSS-only Game Boy](https://codepen.io/42EG4M1/pen/wBYmMK) or a [pretty cool starry night](https://codepen.io/seanseansean/pen/JdMMdG) and so much more.\n\nPretty amazing, right?\n\nIn this article, we will highlight how CSS works under the hood, what are the rules CSS uses to evaluate blocks of code, and some tips and tricks that can help you reach the next level in your journey to CSS Mastery.\n\n## How Does CSS actually work?\n\nWhen you start writing HTML, without adding CSS, the browser will render your elements in normal layout flow. Even after adding some CSS to your elements, if you do not change the display or position property, they will still be rendered in the normal flow.\n\nWhat does that even mean?\n\n**The layout model** dictates how your element behaves by default, and what CSS properties your element has access to.\n\nHere are the available layout models:\n\n- Normal Flow\n- Positioned Layout (absolute, block)\n- Flex\n- Grid\n- Table\n\nHave you not noticed that z-index does not work if you do not apply the position property to your element? Well, this is the reason. The property is not available in the normal flow, or in some of the other layouts as well.\n\nAdding position:absolute will switch your element from the normal layout module to the positioned one. In this layout model you have access to extra properties, like z-index.\n\nz-index for example, determines the layout order of elements. If you have two elements in the same position and you want to stack them, the one with the higher z-index value will be on the top.\n\nIf you want to send an element to the bottom of the stack, just set it’s z-index value to a negative number.\n\nA very important detail to remember is that z-index is only useful in the same stacking context.\n\nA stacking context is the collection of child elements inside a parent element. So for example, if we have `.parent1 { z-index: 1; }` and inside we have `.child1 { z-index: 999; }` the child element will not be stacked against other elements outside of the parent.\n\n[Here is a concrete example](https://codepen.io/cst2989/pen/ZExJBKw?editors=1100) to see this in action:\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/stacking.webp\" alt=\"Stacking context example\" /> \n</p>\n\nAs you can see above, it does not matter that child1 has `z-index:999` and child2 has `z-index:-1` because we compare their stacking context.\n\nSo each layout model has its own properties and rules. And it shares some common ones as well. For example, both flex and grid contain the gap property to set the spacing between the items.\n\nFrom this, it’s only a matter of figuring out what properties are implemented in which layout model, and then you will have fewer problems with CSS behaving differently from one context to another.\n\n## Specificity. Rules are made to be followed\n\nIt took me a while to understand how specificity worked in CSS. It seemed unimportant (ironically) because everything just worked.\n\nSo what if sometimes I had to add a few `!important` here and there. Or move some code blocks lower in the CSS file to make sure they are applied last. Or worst-case scenario, duplicate some code for different classes. In the end, it worked and that was what mattered at the time.\n\nI realized how wasteful I was when I had to write optimized code for web applications visited by millions of users. And how hard to debug my code actually was, and little by little I started to understand the rules the Browser Gods act upon us mortals.\n\nSo what is specificity and how does CSS work? Here is the definition from [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity):\n\n> Specificity is the means by which a browser decides which CSS property values are the most relevant to an element and therefore will be applied. Specificity is only based on the matching rules which are composed of CSS selectors of different sorts.\n\nBasically, the Browser looks at your CSS rule and gives it a score. Actually 4 scores.\n\nFour numbers separated by a comma `0, 0, 0, 0`\n\nThen when you have two colliding CSS rules it goes through the first digit and compares them if there is no clear winner it goes to the second digit and so on.\n\nIf all columns are equal, the browser will pick the rule based on the order. Here is where the Cascade name comes into place. It takes the one closer to the bottom.\n\nHere is the breakdown of the four digits:\n\nThe first digit represents if the element has inline styles.\n\n```\n<p style=\"color:red\">Hello World</p>\n```\n\nThe second digit represents the number of #ids in your CSS rule.\n\n```\n<p id=\"myParagraph\">Hello World</p>\n```\nor\n```\n#myParagraph {\n  color: blue;\n}\n```\nThe third digit is the number of classes, pseudo-classes, and attributes your CSS rule has.\n\n```<p class=\"myParagraphClass\">Hello World</p>\n<style>\n.myParagraphClass {\n  color: green;\n}\n</style>\n```\nAnd lastly, we have the number of elements and pseudo-elements.\n```\n<p>Hello World</p>\n<style>\np {\n  color: yellow;\n}\n</style>\n```\n\nSo for each rule in each column, we increase the score of that column.\n\nNow you may have read that inline-styles give you a score of 1000, ids of 100, and so forth. This is not true.\n\nFor example. Let’s say we have an element with 102 classes and just one ID. Like the following code:\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/code.png\" alt=\"Stacking context example\" /> \n</p>\n\nIf you would follow the rule recommended by some articles and w3school, the ID should have a score of 100, and the class should have a score of 103 resulting in a blue `Hello World` text. But if you check this in your browser it’s actually red.\n\nBrowsers do not compare apples with oranges. The browser first checks if we have conflicting rules at the inline-style level and applies the score there, then goes to IDs and so on and so forth.\n\nAnother example would be:\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/code2.png\" alt=\"Stacking context example\" /> \n</p>\n\nThe `#test { color: red; }` has a specificity score of `0,1,0,0`. While the second CSS rule `.test-1-parent #test { color: yellow; }` has a specificity score of `0,1,1,0`. The first column is equal, so the Browser moves to the second column where both have a value of 1. \n\nThen we move to the third column where color:yellow is the winner.\n\n## Collapsing Margins\n\n> “In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.“ — W3C\n\nI am ashamed to admit this, but in my second to the third year as a professional developer, I did not know about collapsing margins. Even worse than that, in my ignorance, I would argue with designers that complained that the spacing between elements was off.\n\nI would open the DevTools and show them, margin-top:50px see? And they would nod, in that I-see-it-but-I-don't-believe-it way.\n\nFor this, I want to formally apologize to all designers that I did this to or to all designers that suffer from this because of ignorant developers like me.\n\nHopefully, I can make amends with this article and educate other poor ignorant frontend developers and you will never have to go through this again.\n\nAs you can imagine, collapsing margins, are the reason even though we had margin-top:50px; on the element the margin could be different. And here is why.\n\nWhen two vertical margins (top and bottom) interact with one another, CSS has a weird rule, it makes them duke it out and the bigger one wins.\n\nFor example two HTML elements on the same level in the DOM, `.div1 { margin-bottom: 30px; }` and `.div2 { margin-top: 20px; }` , you would expect the distance to be the sum of the margins. But in fact, the collapsing margin rule comes into effect, and we only have 30px (the bigger margin from .div1) between them.\n\nOn the other hand, if one of the elements has a negative margin, `.div2 { margin-top: -20px; }` then it behaves as you expect. And the margin between them is the sum of 10px.\n\nMore mind-blowing though is when both elements have negative margins. For example, `.div1 { margin-bottom: -50px; }` and `.div2 { margin-top: -20px; }` you would expect again, either the sum or the biggest in mathematical terms to be the result, as we know -20 is bigger than -50 because it's closer to zero, but NO who invented CSS said no to proper maths and the margin between them is -50px. Amazing!\n\n[Here is a Codepen](https://codepen.io/cst2989/pen/eYMRQwE) to simulate all examples:\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/collapsing.webp\" alt=\"Collapsing margin example\" /> \n</p>\n\nOne more thing to take into consideration is the parent-child relationship between elements where again collapsing margins can cause trouble.\n\nIf the parent element has a margin, let's say .parent { margin-top: 50px; } and the first child of this element also has a margin .child-1 { margin-top: 20px; } the margins will collapse again and we will only see the bigger one.\n\n[Here is an example](https://codepen.io/cst2989/pen/oNqwJgQ):\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/child-margin.webp\" alt=\"Child margin example\" /> \n</p>\nSo that’s how collapsin\ng margins work. Now you may be wondering how to stop it. Easily enough, if you apply anything between the margins, like a border-top or a padding-top then the margins will not touch each other and will not collapse at all.\n\nThink about this physical barrier as the referee that keeps two boxers at bay from fighting each other when the round ends.\n\n## In Conclusion\nCSS is hard! It has all sorts of wacky behavior. But if you know on which layout model you are, you have a better chance of figuring it out.\n\nSpecificity rules are there to decide between conflicting CSS properties. Remember the 4 levels and how to count the score.\n\nAnd if margins are giving you a problem, remember that the physical barrier between your elements will keep them from fighting each other\n\nYou know what they say, a `border-top: 1px solid transparent`, keep the collapsing margins away.\n\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"how-does-css-actually-work","text":"How Does CSS actually work?"},{"depth":2,"slug":"specificity-rules-are-made-to-be-followed","text":"Specificity. Rules are made to be followed"},{"depth":2,"slug":"collapsing-margins","text":"Collapsing Margins"},{"depth":2,"slug":"in-conclusion","text":"In Conclusion"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
