import { f as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_b7d88353.mjs';
import 'clsx';

const html = "<p>We used to have a small annoying problem in my company. I call it small-annoying because it was small enough not to deserve allocated resources to solve, but it was annoying enough to bother me every couple of weeks.</p>\n<p>We have a Frontend React Application that communicates to a backend API, a gateway to multiple services, and one main monolithic application.</p>\n<p>It’s a standard architecture, so let me know if this has ever happened to you.</p>\n<p>You need to do a production release; you last did one about ten days ago, and now that the stars have aligned, you have the perfect window to press the button.</p>\n<p>The problem? You have no idea what exactly you are releasing.</p>\n<p>And here you can see how annoying this was for me. As I usually was in charge of pushing the deploy button, I had to ensure everything in line to be released was tested, verified, and given the green light to be deployed.</p>\n<p>Here is what the process looks like:</p>\n<p>First, I check the status of JIRA tickets for <code>Ready for Release</code> and write down the ticket number and title. Then, I go commit by commit in the Frontend React Application, note the JIRA tickets in the title, write them down, and do the same for our Backend Go Application and other services.</p>\n<p>Finally, I had a list that looked like this:</p>\n<img src=\"/images/articles/first-notes.png\" alt=\"First Notes for Release\"> \n<p>Gathering all this information took me around 30 minutes; like I said, it was a small problem.</p>\n<p>Then, I posted on different development Slack channels, letting the team know what was being released and asking anybody with any objections to speak now or face the consequences.</p>\n<p>Finally, I would push the button, release the main branch to Production, and let everybody know in the #general Slack channel. We would do some manual tests, everybody would be happy, and a few days later, we would repeat the experience.</p>\n<p>Sometimes, the annoyance grows and becomes a real problem. I might forget to announce releases, and stakeholders will be confused about what is in Production. Some bugs might sneak their way because I missed them in the commit list, or worse, dependency deployments might cause the app to crash.</p>\n<p>After several times when it became a problem and people complained about it,  I finally got around to automating this process.</p>\n<p>Here is what I need from this feature:</p>\n<ul>\n<li>Semver versioning</li>\n<li>Github Action that adds the title of PR and content to the changelog  when the PR is merged</li>\n<li>A button that creates a new release tag gets everything in the changelog and sets it as the description for the release</li>\n<li>Sends Slack notifications to a specific channel with release notes</li>\n</ul>\n<p>Let’s get pull up our sleeves and get to work.</p>\n<h2 id=\"semantic-versioning-aka-semver\">Semantic versioning (aka SemVer)</h2>\n<p>Not all PRs are the same; some have complex features that took weeks to build, while others have small fixes of current implementations, different chores, or security patches.</p>\n<p>This is what semantic versioning represents. It is a series of numbers that lets everybody looking at your project know what the next version has inside of it.</p>\n<p>You see it all the time in npm packages. It’s three numbers that are separated by single dots Ex: 1.0.0 :</p>\n<img src=\"/images/articles/semver.jpg\" alt=\"Semver Explained\"> \n<p>The first number represents a major change containing breaking changes. That means if you use this project and upgrade to this version, you would have to change how you use it for it to work. It’s typical for a rebrand of your project, or you add multiple sets of features or change the API of how your features work.</p>\n<p>The second number represents minor versions that add non-breaking changes, such as new features, components, style changes, etc. If I use your project and upgrade to this version, it will work without changing anything in my code.</p>\n<p>Lastly, the patch version is the last number, representing quick fixes, security patches, or small improvement requests.</p>\n<p>There you have it, SemVer explained. We want this for our release notes; let’s see how we can implement it.</p>\n<h2 id=\"magic-github-action\">Magic Github Action</h2>\n<p>Have you ever had those repetitive tasks you do whenever you merge code? GitHub Actions solves those problems. Instead of manually creating tags, updating changelogs, and writing release notes, you set up a workflow file and let GitHub handle it.</p>\n<p>It’s like having a tiny dev that sits there watching your repository 24/7, ready to jump in whenever you merge code. Here’s how I configured ours:</p>\n<p>We already had the practice of naming our PRs depending on the type of change we are introducing, for example:\nfeat(COM-1000): this is a new feature\nfix(COM-666): fixed an annoying bug\nchore(COM-123): updates the README file\nmajor(COM-1444): this is a major breaking change that requires both frontend and backend to be carefully deployed, or else we have a problem</p>\n<p>The next step was to use this title somewhere, and I knew just the place. GitHub already integrates releases based on tags; the problem is that you have to write the release description yourself.</p>\n<p>I decided to write a GitHub Actions script that does the following when you merge a PR:</p>\n<ul>\n<li>Creates a “Draft Release” or takes the one that already exists</li>\n<li>The next version is calculated based on the PR title and the previous tag version, and a tag is created.</li>\n<li>It does this at every PR merge as long you have yet to release it and keeps adding the titles to the Draft Release.\nHere is what the flow would look like.</li>\n</ul>\n<p>We just released version 2.10 in Production yesterday, and today, we’re merging three tickets:</p>\n<p>First is fix(COM-666): fixed an annoying bug. The GitHub Action checks the current latest tag (2.10.0) and, since this is a fix, bumps the patch version to 2.10.1. It creates a draft release and adds the PR title under the “Patches” section.</p>\n<p>Next, we merge feat(COM-789): add new login page. The Action sees this is a feature, so it bumps the minor version to 2.11.0 and adds the PR title under “Minor Changes” in the same draft release.</p>\n<p>Finally, we merge chore(COM-999): update dependencies. Another patch, so it becomes 2.11.1.</p>\n<p>Let’s break down how this works in the code. To use this in your project, create a .github folder inside the root of your project (if you don’t have one already); inside it, create a workflow director and add a file named <code>semantic-versioning.yml</code> :</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>name: Semantic Versioning and Draft Release</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>on:</span></span>\n<span class=\"line\"><span>  pull_request:</span></span>\n<span class=\"line\"><span>    types: [closed]</span></span>\n<span class=\"line\"><span>    branches:</span></span>\n<span class=\"line\"><span>      - main</span></span></code></pre>\n<p>This code tells our tiny dev, “Hey, only wake up when someone merges a PR to main.” Because that’s when we want to update our release notes.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>jobs:</span></span>\n<span class=\"line\"><span>  process-pr:</span></span>\n<span class=\"line\"><span>    if: github.event.pull_request.merged == true</span></span>\n<span class=\"line\"><span>    runs-on: ubuntu-latest</span></span>\n<span class=\"line\"><span>    permissions:</span></span>\n<span class=\"line\"><span>      contents: write</span></span></code></pre>\n<p>The if condition is crucial here - we don’t want to create release notes for PRs that were closed without merging. That would be messy. And we need contents: write permission because, well, we’re going to be creating tags and messing with releases.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>steps:</span></span>\n<span class=\"line\"><span>  - name: Checkout code</span></span>\n<span class=\"line\"><span>    uses: actions/checkout@v3</span></span>\n<span class=\"line\"><span>    with:</span></span>\n<span class=\"line\"><span>      fetch-depth: 0</span></span>\n<span class=\"line\"><span>      token: ${{ secrets.GITHUB_TOKEN }}</span></span></code></pre>\n<p>Steps in GitHub Actions are sequential tasks that run one after another. Think of them as recipes—each step needs to be completed successfully before proceeding to the next one. The <code>uses: actions/checkout@v3</code> tells GitHub to use version 3 of the official checkout action, a pre-built action that handles git clone operations.</p>\n<p>The checkout step clones our repository into the GitHub Actions runner. The workflow needs access to our code to process tags and create releases, which is where the GITHUB_TOKEN comes in - it’s an automatically generated token that GitHub creates for each workflow run with the permissions we specified earlier.</p>\n<p>GitHub Actions fetches the latest commit by default to save time and bandwidth. But for versioning, we need the complete git history, including all tags. That’s what fetch-depth: 0 does - it tells git to fetch everything.</p>\n<p>Then we get in the meat of our business: first, it fetches the latest version tag:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>- name: Get latest tag</span></span>\n<span class=\"line\"><span>  run: |</span></span>\n<span class=\"line\"><span>    git fetch --tags</span></span>\n<span class=\"line\"><span>    LATEST_TAG=$(git tag -l | sort -V | tail -n 1)</span></span></code></pre>\n<p>Then comes the interesting part - determining the version bump based on the PR title:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>if [[ $PR_TITLE == *\"BREAKING CHANGE\"* ]] || [[ $PR_TITLE == *\"major\"* ]]; then</span></span>\n<span class=\"line\"><span>  BUMP_TYPE=\"major\"</span></span>\n<span class=\"line\"><span>elif [[ $PR_TITLE == *\"feat:\"* ]] || [[ $PR_TITLE == *\"minor\"* ]]; then</span></span>\n<span class=\"line\"><span>  BUMP_TYPE=\"minor\"</span></span>\n<span class=\"line\"><span>elif [[ $PR_TITLE == *\"fix:\"* ]] || [[ $PR_TITLE == *\"patch\"* ]]; then</span></span>\n<span class=\"line\"><span>  BUMP_TYPE=\"patch\"</span></span>\n<span class=\"line\"><span>fi</span></span></code></pre>\n<p>It looks for keywords in the PR title - “BREAKING CHANGE” or “major” bumps the major version, “feat:” bumps minor, and “fix:” bumps patch. The version is calculated by splitting the current version and incrementing the correct number:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>case $BUMP_TYPE in</span></span>\n<span class=\"line\"><span>  major)</span></span>\n<span class=\"line\"><span>    NEW_VERSION=\"$((MAJOR + 1)).0.0\"</span></span>\n<span class=\"line\"><span>    ;;</span></span>\n<span class=\"line\"><span>  minor)</span></span>\n<span class=\"line\"><span>    NEW_VERSION=\"${MAJOR}.$((MINOR + 1)).0\"</span></span>\n<span class=\"line\"><span>    ;;</span></span>\n<span class=\"line\"><span>  patch)</span></span>\n<span class=\"line\"><span>    NEW_VERSION=\"${MAJOR}.${MINOR}.$((PATCH + 1))\"</span></span>\n<span class=\"line\"><span>    ;;</span></span>\n<span class=\"line\"><span>esac</span></span></code></pre>\n<p>Finally, it updates the draft release by adding the PR title under the right section (Breaking Changes, Minor Changes, or Patches). If no draft exists, it creates one:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>if gh release view \"Latest Release\" --json body &#x26;>/dev/null; then</span></span>\n<span class=\"line\"><span>  CURRENT_BODY=$(gh release view \"Latest Release\" --json body -q '.body')</span></span>\n<span class=\"line\"><span>  NEW_BODY=$(update_release_body \"$CURRENT_BODY\" \"$SECTION\" \"${{ env.PR_ENTRY }}\")</span></span>\n<span class=\"line\"><span>  echo \"$NEW_BODY\" | gh release edit \"Latest Release\" --draft --notes-file -</span></span>\n<span class=\"line\"><span>else</span></span>\n<span class=\"line\"><span>  NEW_BODY=$(update_release_body \"\" \"$SECTION\" \"${{ env.PR_ENTRY }}\")</span></span>\n<span class=\"line\"><span>  echo \"$NEW_BODY\" | gh release create \"Latest Release\" --draft --title \"Latest Release\" --notes-file -</span></span>\n<span class=\"line\"><span>fi</span></span></code></pre>\n<p>Now, whenever someone merges a PR, the release notes are written by themselves. The draft release keeps collecting changes until we’re ready to publish it to Production. Here is what it looks like:</p>\n<img src=\"/images/articles/latest-release-draft.png\" alt=\"Github Latest Release Draft\"> \n<h2 id=\"pressing-the-button\">Pressing the button</h2>\n<p>Now that we have a Draft Release, we are always aware of what is in the main, and we can deploy it anytime.</p>\n<p>Of course, you can do it manually by publishing the draft release, but I wanted to add some extra things when a release is published.</p>\n<p>Remember semantic versioning? I want the GitHub Action to get the latest tag and name the release with that tag. Then, I want to change the version in our package.json file to that specific version. Finally, I want our GitHub Action to create a release branch from our main branch, which we can use to deploy to Production automatically.</p>\n<p>Let’s implement this new flow.</p>\n<p>First, we create another workflow called <code>publish-release.yml</code> in our workflows folder. This one is a little different, as we don’t want it to run automatically; we have to specify its manual:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>name: Create Release Branch and Release</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span>on:</span></span>\n<span class=\"line\"><span>  workflow_dispatch:</span></span></code></pre>\n<p>This code will create a nice green button in the GitHub Actions tab that, when pressed, will run our GitHub Action like so:</p>\n<img src=\"/images/articles/run-workflow.png\" alt=\"Run Workflow image in Github\"> \n<p>We break our workflow into three main steps:</p>\n<ul>\n<li>prepare step</li>\n<li>create-release-branch</li>\n<li>publish-release</li>\n</ul>\n<p>Our <code>prepare</code> step is pretty standard. It gets the code from our code repository, declares our output, and sets the GitHub token to allow our workflow to push changes to it. Finally, it gets the latest tag of our repo and stores it as a variable for later usage.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>jobs:</span></span>\n<span class=\"line\"><span>  prepare:</span></span>\n<span class=\"line\"><span>    runs-on: ubuntu-latest</span></span>\n<span class=\"line\"><span>    outputs:</span></span>\n<span class=\"line\"><span>      latest_tag: ${{ steps.get_tag.outputs.tag }}</span></span>\n<span class=\"line\"><span>    steps:</span></span>\n<span class=\"line\"><span> - name: Checkout code</span></span>\n<span class=\"line\"><span>        uses: actions/checkout@v3</span></span>\n<span class=\"line\"><span>        with:</span></span>\n<span class=\"line\"><span>          fetch-depth: 0</span></span>\n<span class=\"line\"><span>          token: ${{ secrets.GITHUB_TOKEN }}</span></span>\n<span class=\"line\"><span>- name: Get latest tag</span></span>\n<span class=\"line\"><span>        id: get_tag</span></span>\n<span class=\"line\"><span>        run: |</span></span>\n<span class=\"line\"><span>          LATEST_TAG=$(git tag -l | sort -V | tail -n 1)</span></span>\n<span class=\"line\"><span>          echo \"tag=$LATEST_TAG\" >> $GITHUB_OUTPUT</span></span></code></pre>\n<p>Next, our <code>create-release-branch</code> job needs write permissions to the repository. It deletes the current release branch because we no longer need it and creates a new release branch from the main branch.</p>\n<p>With the release branch created, it writes the latest tag into the package.json and finally pushes the changes to the repository.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>  create-release-branch:</span></span>\n<span class=\"line\"><span>    needs: prepare</span></span>\n<span class=\"line\"><span>    runs-on: ubuntu-latest</span></span>\n<span class=\"line\"><span>    permissions:</span></span>\n<span class=\"line\"><span>      contents: write</span></span>\n<span class=\"line\"><span>    steps:</span></span>\n<span class=\"line\"><span> - uses: actions/checkout@v4</span></span>\n<span class=\"line\"><span>        with:</span></span>\n<span class=\"line\"><span>          ref: main</span></span>\n<span class=\"line\"><span>          token: ${{ secrets.GITHUB_TOKEN }}</span></span>\n<span class=\"line\"><span>      </span></span>\n<span class=\"line\"><span> - name: Update package version and create branch</span></span>\n<span class=\"line\"><span>        run: |</span></span>\n<span class=\"line\"><span>          # Get the latest tag</span></span>\n<span class=\"line\"><span>          LATEST_TAG=${{ needs.prepare.outputs.latest_tag }}</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          # Delete release branch locally and remotely if it exists</span></span>\n<span class=\"line\"><span>          git push origin --delete release || true</span></span>\n<span class=\"line\"><span>          git branch -D release || true</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          # Create new release branch from main</span></span>\n<span class=\"line\"><span>          git checkout -b release</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          # Update version in package.json directly</span></span>\n<span class=\"line\"><span>          jq \".version = \\\"${LATEST_TAG}\\\"\" package.json > temp.json &#x26;&#x26; mv temp.json package.json</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          echo \"Updated package.json to version ${LATEST_TAG}\"</span></span>\n<span class=\"line\"><span>          cat package.json | grep version</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          # Configure git</span></span>\n<span class=\"line\"><span>          git config user.name \"github-actions[bot]\"</span></span>\n<span class=\"line\"><span>          git config user.email \"github-actions[bot]@users.noreply.github.com\"</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          # Commit and push changes</span></span>\n<span class=\"line\"><span>          git add package.json</span></span>\n<span class=\"line\"><span>          git commit -m \"chore: update version to ${LATEST_TAG}\"</span></span>\n<span class=\"line\"><span>          git push -f origin release</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<p>What we have now is a branch named <code>release</code> with the latest commit and the version name. We can then use this in our CI/CD Netlify or Vercel or whatever Cloud provider you want to automatically release this branch to Production every time some new code is pushed to it.</p>\n<img src=\"/images/articles/published-to-netlify.png\" alt=\"Publish to Netlify example\"> \n<p>And now, finally, if the previous two jobs were successful, we can publish our release with the adequately named job <code> publish-release</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>  publish-release:</span></span>\n<span class=\"line\"><span>    needs: [prepare, create-release-branch]</span></span>\n<span class=\"line\"><span>    runs-on: ubuntu-latest</span></span>\n<span class=\"line\"><span>    permissions:</span></span>\n<span class=\"line\"><span>      contents: write</span></span>\n<span class=\"line\"><span>    steps:</span></span>\n<span class=\"line\"><span> - name: Checkout code</span></span>\n<span class=\"line\"><span>        uses: actions/checkout@v3</span></span>\n<span class=\"line\"><span>        with:</span></span>\n<span class=\"line\"><span>          fetch-depth: 0</span></span>\n<span class=\"line\"><span>          token: ${{ secrets.GITHUB_TOKEN }}</span></span>\n<span class=\"line\"><span></span></span>\n<span class=\"line\"><span> - name: Publish draft release</span></span>\n<span class=\"line\"><span>        env:</span></span>\n<span class=\"line\"><span>          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</span></span>\n<span class=\"line\"><span>        run: |</span></span>\n<span class=\"line\"><span>          # Use the tag from prepare job</span></span>\n<span class=\"line\"><span>          LATEST_TAG=${{ needs.prepare.outputs.latest_tag }}</span></span>\n<span class=\"line\"><span>          </span></span>\n<span class=\"line\"><span>          # Update the draft release title and publish it</span></span>\n<span class=\"line\"><span>          gh release edit \"Latest Release\" --title \"$LATEST_TAG\" --tag \"$LATEST_TAG\" --draft=false</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<p>There you have it: click a button, and magic happens. This will publish the release to the latest version so you can see it in the releases tab on GitHub and start again with more PR merges.</p>\n<h2 id=\"getting-notified\">Getting Notified</h2>\n<p>The final piece of the puzzle was getting these release notes to where people actually hang out - Slack. You know how it goes, you can have the most beautiful documentation in the world, but if people need to actively go looking for it, they probably won’t.</p>\n<p>Let me tell you about the easiest integration I’ve ever done.</p>\n<p>First, head over to <a href=\"https://slack.github.com/\">https://slack.github.com/</a> and install the GitHub-Slack app. It’s the official app, so you know it’s safe and well-maintained.</p>\n<p>Next, you’ll want to create some dedicated channels for these notifications. In our case, we created two: #frontend-releases and #backend-releases.</p>\n<p>Finally, here’s the magic part. Go to your new channel and type this command:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>/github subscribe owner/repo releases</span></span></code></pre>\n<p>Just replace “owner” and “repo” with your actual GitHub details. For example, if your repo lives at <a href=\"https://github.com/cst2989/release-notes\">https://github.com/cst2989/release-notes</a>, you’d type:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\"><code><span class=\"line\"><span>/github subscribe cst2989/release-notes releases</span></span></code></pre>\n<p>That’s it! Every time you publish a release, Slack will automatically post the release notes in your channel. There are no webhooks to configure or custom integrations to maintain, just instant notifications where your team already lives.</p>\n<p>And remember those beautifully formatted release notes we set up earlier? They’ll show up in Slack looking just as clean and organized. Your team will always know exactly what’s going into Production, and more importantly, they’ll actually see it.</p>\n<img src=\"/images/articles/final-release-message.png\" alt=\"Slack message with release notes\"> \n<h2 id=\"conclusion-and-alternatives\">Conclusion and Alternatives</h2>\n<p>If you want to keep track of all the PRs you are merging in a clean way, you can use the GitHub Actions above to automate your release notes.</p>\n<p>Doing this will save you time, reduce human error, and keep your team informed about what’s going into Production.</p>\n<p>I would also reccomend an open source Github Action you can find on the marketplace called <code>release-drafter</code> <a href=\"https://github.com/release-drafter/release-drafter\">https://github.com/release-drafter/release-drafter</a> that does the same thing but with a little more configuration and it allows to create templates.</p>";

				const frontmatter = {"title":"Magic Release Notes","excerpt":"Just merge your PRs without worrying about release notes. Let GitHub Actions do the work for you by creating a Draft Release and then push to production by clicking a button and get notified on Slack.","publishDate":"2025-01-18T00:00:00.000Z","image":"/images/articles/magic-release-bg.png","category":"deployment","readTime":"5 min read","readingTime":13};
				const file = "/Users/danneciu/Desktop/apps/neciudan-dev-v2/src/content/post/magic-release-notes.md";
				const url = undefined;
				function rawContent() {
					return "\nWe used to have a small annoying problem in my company. I call it small-annoying because it was small enough not to deserve allocated resources to solve, but it was annoying enough to bother me every couple of weeks. \n\nWe have a Frontend React Application that communicates to a backend API, a gateway to multiple services, and one main monolithic application. \n\nIt's a standard architecture, so let me know if this has ever happened to you. \n\nYou need to do a production release; you last did one about ten days ago, and now that the stars have aligned, you have the perfect window to press the button. \n\nThe problem? You have no idea what exactly you are releasing.\n\nAnd here you can see how annoying this was for me. As I usually was in charge of pushing the deploy button, I had to ensure everything in line to be released was tested, verified, and given the green light to be deployed. \n\nHere is what the process looks like:\n\nFirst, I check the status of JIRA tickets for `Ready for Release` and write down the ticket number and title. Then, I go commit by commit in the Frontend React Application, note the JIRA tickets in the title, write them down, and do the same for our Backend Go Application and other services. \n\nFinally, I had a list that looked like this: \n\n<img src=\"/images/articles/first-notes.png\" alt=\"First Notes for Release\" /> \n\nGathering all this information took me around 30 minutes; like I said, it was a small problem. \n\nThen, I posted on different development Slack channels, letting the team know what was being released and asking anybody with any objections to speak now or face the consequences.\n\nFinally, I would push the button, release the main branch to Production, and let everybody know in the #general Slack channel. We would do some manual tests, everybody would be happy, and a few days later, we would repeat the experience. \n\nSometimes, the annoyance grows and becomes a real problem. I might forget to announce releases, and stakeholders will be confused about what is in Production. Some bugs might sneak their way because I missed them in the commit list, or worse, dependency deployments might cause the app to crash. \n\nAfter several times when it became a problem and people complained about it,  I finally got around to automating this process. \n\nHere is what I need from this feature: \n- Semver versioning \n- Github Action that adds the title of PR and content to the changelog  when the PR is merged\n- A button that creates a new release tag gets everything in the changelog and sets it as the description for the release \n- Sends Slack notifications to a specific channel with release notes\n\nLet's get pull up our sleeves and get to work.\n\n## Semantic versioning (aka SemVer)\n\nNot all PRs are the same; some have complex features that took weeks to build, while others have small fixes of current implementations, different chores, or security patches. \n\nThis is what semantic versioning represents. It is a series of numbers that lets everybody looking at your project know what the next version has inside of it. \n\nYou see it all the time in npm packages. It's three numbers that are separated by single dots Ex: 1.0.0 : \n\n<img src=\"/images/articles/semver.jpg\" alt=\"Semver Explained\" /> \n\nThe first number represents a major change containing breaking changes. That means if you use this project and upgrade to this version, you would have to change how you use it for it to work. It's typical for a rebrand of your project, or you add multiple sets of features or change the API of how your features work. \n\nThe second number represents minor versions that add non-breaking changes, such as new features, components, style changes, etc. If I use your project and upgrade to this version, it will work without changing anything in my code. \n\nLastly, the patch version is the last number, representing quick fixes, security patches, or small improvement requests. \n\nThere you have it, SemVer explained. We want this for our release notes; let's see how we can implement it. \n\n## Magic Github Action\n\nHave you ever had those repetitive tasks you do whenever you merge code? GitHub Actions solves those problems. Instead of manually creating tags, updating changelogs, and writing release notes, you set up a workflow file and let GitHub handle it.\n\nIt's like having a tiny dev that sits there watching your repository 24/7, ready to jump in whenever you merge code. Here's how I configured ours:\n\nWe already had the practice of naming our PRs depending on the type of change we are introducing, for example:\nfeat(COM-1000): this is a new feature \nfix(COM-666): fixed an annoying bug \nchore(COM-123): updates the README file \nmajor(COM-1444): this is a major breaking change that requires both frontend and backend to be carefully deployed, or else we have a problem\n\nThe next step was to use this title somewhere, and I knew just the place. GitHub already integrates releases based on tags; the problem is that you have to write the release description yourself. \n\nI decided to write a GitHub Actions script that does the following when you merge a PR: \n- Creates a \"Draft Release\" or takes the one that already exists \n- The next version is calculated based on the PR title and the previous tag version, and a tag is created.\n- It does this at every PR merge as long you have yet to release it and keeps adding the titles to the Draft Release. \nHere is what the flow would look like. \n\nWe just released version 2.10 in Production yesterday, and today, we're merging three tickets:\n\nFirst is fix(COM-666): fixed an annoying bug. The GitHub Action checks the current latest tag (2.10.0) and, since this is a fix, bumps the patch version to 2.10.1. It creates a draft release and adds the PR title under the \"Patches\" section.\n\nNext, we merge feat(COM-789): add new login page. The Action sees this is a feature, so it bumps the minor version to 2.11.0 and adds the PR title under \"Minor Changes\" in the same draft release.\n\nFinally, we merge chore(COM-999): update dependencies. Another patch, so it becomes 2.11.1.\n\nLet's break down how this works in the code. To use this in your project, create a .github folder inside the root of your project (if you don't have one already); inside it, create a workflow director and add a file named `semantic-versioning.yml` :\n\n```\nname: Semantic Versioning and Draft Release\n\non:\n  pull_request:\n    types: [closed]\n    branches:\n      - main\n```\n\nThis code tells our tiny dev, \"Hey, only wake up when someone merges a PR to main.\" Because that's when we want to update our release notes.\n\n```\njobs:\n  process-pr:\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n```\n\nThe if condition is crucial here - we don't want to create release notes for PRs that were closed without merging. That would be messy. And we need contents: write permission because, well, we're going to be creating tags and messing with releases.\n\n```\nsteps:\n  - name: Checkout code\n    uses: actions/checkout@v3\n    with:\n      fetch-depth: 0\n      token: ${{ secrets.GITHUB_TOKEN }}\n```\nSteps in GitHub Actions are sequential tasks that run one after another. Think of them as recipes—each step needs to be completed successfully before proceeding to the next one. The `uses: actions/checkout@v3` tells GitHub to use version 3 of the official checkout action, a pre-built action that handles git clone operations.\n\nThe checkout step clones our repository into the GitHub Actions runner. The workflow needs access to our code to process tags and create releases, which is where the GITHUB_TOKEN comes in - it's an automatically generated token that GitHub creates for each workflow run with the permissions we specified earlier.\n\nGitHub Actions fetches the latest commit by default to save time and bandwidth. But for versioning, we need the complete git history, including all tags. That's what fetch-depth: 0 does - it tells git to fetch everything.\n\nThen we get in the meat of our business: first, it fetches the latest version tag:\n\n```\n- name: Get latest tag\n  run: |\n    git fetch --tags\n    LATEST_TAG=$(git tag -l | sort -V | tail -n 1)\n```\n\nThen comes the interesting part - determining the version bump based on the PR title:\n\n```\nif [[ $PR_TITLE == *\"BREAKING CHANGE\"* ]] || [[ $PR_TITLE == *\"major\"* ]]; then\n  BUMP_TYPE=\"major\"\nelif [[ $PR_TITLE == *\"feat:\"* ]] || [[ $PR_TITLE == *\"minor\"* ]]; then\n  BUMP_TYPE=\"minor\"\nelif [[ $PR_TITLE == *\"fix:\"* ]] || [[ $PR_TITLE == *\"patch\"* ]]; then\n  BUMP_TYPE=\"patch\"\nfi\n```\n\nIt looks for keywords in the PR title - \"BREAKING CHANGE\" or \"major\" bumps the major version, \"feat:\" bumps minor, and \"fix:\" bumps patch. The version is calculated by splitting the current version and incrementing the correct number:\n\n```\ncase $BUMP_TYPE in\n  major)\n    NEW_VERSION=\"$((MAJOR + 1)).0.0\"\n    ;;\n  minor)\n    NEW_VERSION=\"${MAJOR}.$((MINOR + 1)).0\"\n    ;;\n  patch)\n    NEW_VERSION=\"${MAJOR}.${MINOR}.$((PATCH + 1))\"\n    ;;\nesac\n```\n\nFinally, it updates the draft release by adding the PR title under the right section (Breaking Changes, Minor Changes, or Patches). If no draft exists, it creates one:\n\n```\nif gh release view \"Latest Release\" --json body &>/dev/null; then\n  CURRENT_BODY=$(gh release view \"Latest Release\" --json body -q '.body')\n  NEW_BODY=$(update_release_body \"$CURRENT_BODY\" \"$SECTION\" \"${{ env.PR_ENTRY }}\")\n  echo \"$NEW_BODY\" | gh release edit \"Latest Release\" --draft --notes-file -\nelse\n  NEW_BODY=$(update_release_body \"\" \"$SECTION\" \"${{ env.PR_ENTRY }}\")\n  echo \"$NEW_BODY\" | gh release create \"Latest Release\" --draft --title \"Latest Release\" --notes-file -\nfi\n```\n\nNow, whenever someone merges a PR, the release notes are written by themselves. The draft release keeps collecting changes until we're ready to publish it to Production. Here is what it looks like: \n\n<img src=\"/images/articles/latest-release-draft.png\" alt=\"Github Latest Release Draft\" /> \n\n## Pressing the button \n\nNow that we have a Draft Release, we are always aware of what is in the main, and we can deploy it anytime. \n\nOf course, you can do it manually by publishing the draft release, but I wanted to add some extra things when a release is published. \n\nRemember semantic versioning? I want the GitHub Action to get the latest tag and name the release with that tag. Then, I want to change the version in our package.json file to that specific version. Finally, I want our GitHub Action to create a release branch from our main branch, which we can use to deploy to Production automatically. \n\nLet's implement this new flow.\n\nFirst, we create another workflow called `publish-release.yml` in our workflows folder. This one is a little different, as we don't want it to run automatically; we have to specify its manual: \n\n```\nname: Create Release Branch and Release\n\non:\n  workflow_dispatch:\n```\n\nThis code will create a nice green button in the GitHub Actions tab that, when pressed, will run our GitHub Action like so: \n\n<img src=\"/images/articles/run-workflow.png\" alt=\"Run Workflow image in Github\" /> \n\nWe break our workflow into three main steps: \n- prepare step\n- create-release-branch\n- publish-release\n\nOur `prepare` step is pretty standard. It gets the code from our code repository, declares our output, and sets the GitHub token to allow our workflow to push changes to it. Finally, it gets the latest tag of our repo and stores it as a variable for later usage.\n\n```\njobs:\n  prepare:\n    runs-on: ubuntu-latest\n    outputs:\n      latest_tag: ${{ steps.get_tag.outputs.tag }}\n    steps:\n - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GITHUB_TOKEN }}\n- name: Get latest tag\n        id: get_tag\n        run: |\n          LATEST_TAG=$(git tag -l | sort -V | tail -n 1)\n          echo \"tag=$LATEST_TAG\" >> $GITHUB_OUTPUT\n```\nNext, our `create-release-branch` job needs write permissions to the repository. It deletes the current release branch because we no longer need it and creates a new release branch from the main branch.\n\nWith the release branch created, it writes the latest tag into the package.json and finally pushes the changes to the repository. \n\n```\n  create-release-branch:\n    needs: prepare\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n - uses: actions/checkout@v4\n        with:\n          ref: main\n          token: ${{ secrets.GITHUB_TOKEN }}\n      \n - name: Update package version and create branch\n        run: |\n          # Get the latest tag\n          LATEST_TAG=${{ needs.prepare.outputs.latest_tag }}\n          \n          # Delete release branch locally and remotely if it exists\n          git push origin --delete release || true\n          git branch -D release || true\n          \n          # Create new release branch from main\n          git checkout -b release\n          \n          # Update version in package.json directly\n          jq \".version = \\\"${LATEST_TAG}\\\"\" package.json > temp.json && mv temp.json package.json\n          \n          echo \"Updated package.json to version ${LATEST_TAG}\"\n          cat package.json | grep version\n          \n          # Configure git\n          git config user.name \"github-actions[bot]\"\n          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n          \n          # Commit and push changes\n          git add package.json\n          git commit -m \"chore: update version to ${LATEST_TAG}\"\n          git push -f origin release\n\n```\n\nWhat we have now is a branch named `release` with the latest commit and the version name. We can then use this in our CI/CD Netlify or Vercel or whatever Cloud provider you want to automatically release this branch to Production every time some new code is pushed to it. \n\n<img src=\"/images/articles/published-to-netlify.png\" alt=\"Publish to Netlify example\" /> \n\nAnd now, finally, if the previous two jobs were successful, we can publish our release with the adequately named job ` publish-release`: \n\n```\n  publish-release:\n    needs: [prepare, create-release-branch]\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GITHUB_TOKEN }}\n\n - name: Publish draft release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n        run: |\n          # Use the tag from prepare job\n          LATEST_TAG=${{ needs.prepare.outputs.latest_tag }}\n          \n          # Update the draft release title and publish it\n          gh release edit \"Latest Release\" --title \"$LATEST_TAG\" --tag \"$LATEST_TAG\" --draft=false\n\n```\n\nThere you have it: click a button, and magic happens. This will publish the release to the latest version so you can see it in the releases tab on GitHub and start again with more PR merges. \n\n## Getting Notified\n\nThe final piece of the puzzle was getting these release notes to where people actually hang out - Slack. You know how it goes, you can have the most beautiful documentation in the world, but if people need to actively go looking for it, they probably won't.\n\nLet me tell you about the easiest integration I've ever done.\n\nFirst, head over to https://slack.github.com/ and install the GitHub-Slack app. It's the official app, so you know it's safe and well-maintained.\n\nNext, you'll want to create some dedicated channels for these notifications. In our case, we created two: #frontend-releases and #backend-releases. \n\nFinally, here's the magic part. Go to your new channel and type this command:\n\n```\n/github subscribe owner/repo releases\n```\n\nJust replace \"owner\" and \"repo\" with your actual GitHub details. For example, if your repo lives at https://github.com/cst2989/release-notes, you'd type:\n\n```\n/github subscribe cst2989/release-notes releases\n```\n\nThat's it! Every time you publish a release, Slack will automatically post the release notes in your channel. There are no webhooks to configure or custom integrations to maintain, just instant notifications where your team already lives.\n\nAnd remember those beautifully formatted release notes we set up earlier? They'll show up in Slack looking just as clean and organized. Your team will always know exactly what's going into Production, and more importantly, they'll actually see it.\n\n<img src=\"/images/articles/final-release-message.png\" alt=\"Slack message with release notes\" /> \n\n## Conclusion and Alternatives\n\nIf you want to keep track of all the PRs you are merging in a clean way, you can use the GitHub Actions above to automate your release notes. \n\nDoing this will save you time, reduce human error, and keep your team informed about what's going into Production.\n\nI would also reccomend an open source Github Action you can find on the marketplace called `release-drafter` https://github.com/release-drafter/release-drafter that does the same thing but with a little more configuration and it allows to create templates.  \n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"semantic-versioning-aka-semver","text":"Semantic versioning (aka SemVer)"},{"depth":2,"slug":"magic-github-action","text":"Magic Github Action"},{"depth":2,"slug":"pressing-the-button","text":"Pressing the button"},{"depth":2,"slug":"getting-notified","text":"Getting Notified"},{"depth":2,"slug":"conclusion-and-alternatives","text":"Conclusion and Alternatives"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
