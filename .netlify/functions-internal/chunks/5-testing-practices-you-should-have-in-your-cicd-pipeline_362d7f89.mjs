const id = "5-testing-practices-you-should-have-in-your-cicd-pipeline.md";
						const collection = "post";
						const slug = "5-testing-practices-you-should-have-in-your-cicd-pipeline";
						const body = "\n## Let me tell you a story…\nWhen I joined my current company, I received a pretty big shock. Out of the 500 engineers employed in three different tech hubs, we had a total of zero QA engineers employed.\n\nFor me, this was an entirely new concept, I moved from my previous company which had either one or two dedicated QA inside a Scrum Development team to ZERO.\n\nI was used to having a fellow teammate go through my branch and add automated tests, API tests, or manually test it for various edge cases and business flows.\n\nWithout that person, what was I gonna do? During the onboarding we received clear instructions that we are supposed to follow the Testing Pyramid:\n\n- Write a lot of unit tests\n- Write some integration tests\n- If the feature is important enough write an E2E test to cover the user's journey.\n- Manually test the feature.\n\nAnd for my first ever task in the team, I was supposed to change something or another in the Sign-Up Dialog (A pretty important part of the application)\n\nAfter I finished with the task at hand, I refactored a little bit to make the code cleaner, and I followed the testing pyramid.\n\n- I wrote unit tests\n- I wrote integration tests\n- I wrote an e2e test\n\nAfter that, I, of course, manually tested the feature with multiple edge cases.\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/wink.jpeg\" alt=\"Wink wink\" /> \n</p>\nAnd the end result? I broke the CSS in almost ALL the dialogs in the application. And of course, as luck would have it, the dialog I was working on did not have this problem — it was great.\n\nSo we realized, pretty early in my tenure, that the testing pyramid was not working.\n\nWe decided to integrate more checks into our CI / CD pipeline to make sure that new joiners, like myself, would not break production as easily.\n\nBut it won't stop developers from dropping the SEO rank of the application, by increasing the Core Web Vitals. For that we need to have Performance tests in place.\n\n## Performance Tests\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/lcp.png\" alt=\"Core Web Vitals\" /> \n</p>\n\nThere is a clear correlation between better Performance and Conversion Rate. And it makes sense, the faster your application loads, the sooner your users can interact with it and buy stuff.\n\nGoogle takes this further and increases the SEO Rank for websites with better Performance. And it ranks performance based on these 3 metrics.\n\n- FID (First Input Delay)\n- LCP (Largest Contentful Paint)\n- CLS (Cumulative Layout Shift)\n\nI am not going to go into details about each of these metrics, but you can read all about them in the official documentation from Google.\n\nWhat we care about is making sure we don't degrade these metrics when we release a feature.\n\nTo accomplish this we are using the recommended tool, Lighthouse CI (It is being maintained by core google members)\n\nOnce you integrated the CI library into your pipeline, writing the performance tests is pretty straightforward.\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/performance-tests.png\" alt=\"Performance Test Example\" /> \n</p>\n\nYou basically care about only one command: cy.lighthouse() which runs the performance checks using the cypress library.\n\nIt boots the app in a browser, goes to the specified link, and compares the performance results to your thresholds — if the result is above the PR is not allowed to be merged.\n\nThese kinds of tests are what we call Lazy Tests. You write them once and forget about them, you don't have to actively maintain them, or write a lot of them for each new feature.\n\n## Mutation Tests\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/mutation-tests.png\" /> \n</p>\n\nAnd speaking of tests that we have to write a lot of… Unit tests have been here for a while.\n\nThey are at the bottom of the old-school pyramid. Considered the most important, because they are fast to run and cheap to write. (Which may no longer be the case in today’s Cloud Run Infrastructure)\n\nBut how do we make sure, that the most important piece of our testing infrastructure, is behaving as expected?\n\nWhat if some of our tests are false positives? They are showing in our terminal and CI as green but are either skipped or worse: they are written badly and are not testing the result of the function under test.\n\n*Mutation Testing* is the solution to our problem. And they work a little differently than normal tests. Usually, you would test that something works as expected, but mutation testing tests that something fails when it's supposed to.\n\nLet’s think about a simple `sum` function.\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/sum.png\" alt=\"Sum Function example\" /> \n</p>\n\nA mutation testing library, would go through this function, analyze the AST and find all the places where it can mutate your function.\n\nFor example, it locates the + operator, and it can change it to different operators like minus, multiplication, etc.\n\nThen the library runs all the tests of this function, and because it changed the operator it expects at least one test to fail. If all of them pass, that means your Mutation Test is kept alive, and you have a bad test suite on your hands.\n\nYou can inspect the mutation later, debug and improve your code.\n\nRinse and repeat until you are satisfied with your Unit Tests and because running Mutation Tests is Expensive, you don't have to add it to your CI pipeline, but can have an async process that does this every other month, to check the integrity of your Unit tests.\n\n## Visual Tests\n\n\nRemember my story from the beginning of the article? Well, that definitely would not have happened if we had Visual Tests in place.\n\nAs the name implies, these tests make sure that visually everything is in order with your pages.\n\nYou can write a test for each type of page you have, and the library you use would boot up that page and take a screenshot. It will then compare that image with the image from the master branch, and ask you if the changes it finds are intentional or mistakes.\n\nWith Visual Tests integrated into your CI pipeline, you will no longer be afraid to touch general components because you might break design in different pages.\n\nThey give you the most confidence when it is about the CSS part of the application.\n\nThe downside of Visual Tests though is that it does not do that well when interactivity is involved.\n\nIf you had to click a button or scroll to the bottom of the page, introducing interactivity also increases flakiness.\n\n## Feature Tests\n\nFeature Tests are the backbone of development these days. Adding Integration tests to your application is no longer a best practice because try as you might simulate a Frontend Application the best result is always achieved when you are testing *like a real user.*\n\nIntegrating different components together and testing the result in a terminal is not what we actually want, these are basically Unit Tests with extra steps (like mocking, stubbing, etc.)\n\nWe want our component to be booted in a browser, in isolation, and to interact with it as a user would.\n\nThis is achieved with *Component Testing*. The library of your choice starts a Single Page Application with just your component. And you can see what a real user is seeing.\n\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/feature1.png\" alt=\"Feature Test example\" /> \n</p>\n\nYou can mount your component with different props, or no props at all, and test the default behavior.\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/feature2.png\" alt=\"Feature Test example\" /> \n</p>\n\nAnd then interact with your component as much as you want, while seeing the result in the browser.\n\nThis is also a good way to develop your component if you like writing TDD.\n\nYou don’t have to start the entire project just to see your small component in action, you can take advantage of the Component testing library and see it there.\n\nTaking one step further, after your component has been tested in isolation you can also add an E2E test if your component is part of an important user journey.\n\nTake care with E2E tests though, usually, they bring with them a lot of problems:\n\n- They are slow\n- They rely on backend Services to dynamically render content\n- The API can have more significant latencies than the E2E library timeout period.\n- You are most definitely testing multiple times the same section of a user's journey.\n\nWe had all these problems and more, and applied some practices to at least reduce the amount of flakiness:\n\n- We run our E2E test suits in parallel, here is a good article on how to achieve this.\n- We implemented Skip Functionality in our tests by mocking cookies or by URL parameters. Example: ?SKIP_LOGIN_FUNCTIONALITY=true, which simulates a logged-in User (Only on testing env).\n- We mocked our entire API by creating our own mock server that records the live response. You can read more about it, here.\n\nYou may think that mocking the entire backend may defeat the purpose of an E2E test. But we have strong consistencies in place, by taking advantage of Contract Testing.\n\n## Contract Tests\n\n<p style=\"text-align: center;\">\n<img src=\"/images/articles/contract.png\" alt=\"Contract Test Workflow\" /> \n</p>\n\nWe found that the most common cause for all our outages was when the API response was different than the front-end application expected.\n\nUsually, this error happened when a calculation in another micro-service fails and the gateway either returns undefined or skips the key in the response entirely.\n\nNow the frontend application, the consumer of the data, declares a contract and says in every endpoint what response it expects and of what values and more importantly what type each value has to be. Some values can still be nullable of course.\n\nYou also declare in your contract, the services you are consuming, in case you have multiple APIs or you, are a backend Service consuming multiple micro-services.\n\nThe Contract is then saved in the testing library that you use, we chose PACT, and for every backend PR, it runs that output of the provider against that Contract. If it fails to respect the contract, the PR is blocked.\n\n\n";
						const data = {publishDate:new Date(1665360000000),title:"5 Testing Practices you should have in your CI / CD Pipeline",excerpt:"Nobody wants bugs in their apps, it could cause your company to lose millions of dollars. Adding these 5 testing practices can prevent it from happening to you.",image:"/images/articles/testing-practices.webp",category:"Software Testing"};
						const _internal = {
							type: 'content',
							filePath: "/Users/danneciu/Desktop/apps/neciudan-dev-v2/src/content/post/5-testing-practices-you-should-have-in-your-cicd-pipeline.md",
							rawData: "\ntitle: '5 Testing Practices you should have in your CI / CD Pipeline'\nexcerpt: 'Nobody wants bugs in their apps, it could cause your company to lose millions of dollars. Adding these 5 testing practices can prevent it from happening to you.'\npublishDate: 2022-10-10\nimage: '/images/articles/testing-practices.webp'\ncategory: 'Software Testing'\nreadTime: '8 min read'",
						};

export { _internal, body, collection, data, id, slug };
